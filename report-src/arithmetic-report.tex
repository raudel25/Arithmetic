%===================================================================================
% JORNADA CIENTÍFICA ESTUDIANTIL - MATCOM, UH
%===================================================================================
% Esta plantilla ha sido diseñada para ser usada en los artículos de la
% Jornada Científica Estudiantil de MatCom.
%
% Por favor, siga las instrucciones de esta plantilla y rellene en las secciones
% correspondientes.
%
% NOTA: Necesitará el archivo 'jcematcom.sty' en la misma carpeta donde esté este
%       archivo para poder utilizar esta plantila.
%===================================================================================



%===================================================================================
% PREÁMBULO
%-----------------------------------------------------------------------------------
\documentclass[a4paper,10pt,twocolumn]{article}

%===================================================================================
% Paquetes
%-----------------------------------------------------------------------------------
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{jcematcom}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[pdftex]{hyperref}
\usepackage{caption}
\usepackage{subcaption}
%-----------------------------------------------------------------------------------
% Configuración
%-----------------------------------------------------------------------------------
\hypersetup{colorlinks,%
	    citecolor=black,%
	    filecolor=black,%
	    linkcolor=black,%
	    urlcolor=blue}

%===================================================================================



%===================================================================================
% Presentacion
%-----------------------------------------------------------------------------------
% Título
%-----------------------------------------------------------------------------------
\title{Documento de Ejemplo para la Jornada Científica Estudiantil}

%-----------------------------------------------------------------------------------
% Autores
%-----------------------------------------------------------------------------------
\author{\\
\name Raudel Alejandro Gómez Molina \email \href{mailto:raudela.gomez@estudiantes.matcom.uh.cu}{raudela.gomez@estudiantes.matcom.uh.cu}
	\\ \addr Grupo C211}

%-----------------------------------------------------------------------------------
% Tutores
%-----------------------------------------------------------------------------------
\tutors{\\
Dr. Tutor Uno, \emph{Centro} \\
Lic. Tutor Dos, \emph{Centro}}

%-----------------------------------------------------------------------------------
% Headings
%-----------------------------------------------------------------------------------
\jcematcomheading{\the\year}{1-\pageref{end}}{Raudel Alejandro Gómez Molina}

%-----------------------------------------------------------------------------------
\ShortHeadings{Ejemplo JCE}{Autores}
%===================================================================================



%===================================================================================
% DOCUMENTO
%-----------------------------------------------------------------------------------
\begin{document}

%-----------------------------------------------------------------------------------
% NO BORRAR ESTA LINEA!
%-----------------------------------------------------------------------------------
\twocolumn[
%-----------------------------------------------------------------------------------

\maketitle

%===================================================================================
% Resumen y Abstract
%-----------------------------------------------------------------------------------
\selectlanguage{spanish} % Para producir el documento en Español

%-----------------------------------------------------------------------------------
% Resumen en Español
%-----------------------------------------------------------------------------------
\begin{abstract}

	Este trabajo tiene como objetivo proponer una implementación de una aritmética basada en las aritméticas de punto fijo que toma como base a las potencias de 10 (siempre y cuando dicha base sea soportada por la aritmética de enteros con que cuenta nuestra computadora). Además compararemos su desempeño en distintos escenarios comparándola con los resultados de otras aritméticas de coma flotante, punto fijo y fracciones racionales.
	
\end{abstract}

%-----------------------------------------------------------------------------------
% English Abstract
%-----------------------------------------------------------------------------------
\vspace{0.5cm}

\begin{enabstract}

	This paper aims to propose an implementation of an arithmetic based on fixed-point arithmetic that takes the powers of 10 as a base (as long as said base is supported by the integer arithmetic available to our computer). We will also compare its performance in different scenarios comparing it with the results of other floating point, fixed point and rational fractions arithmetic.

\end{enabstract}

%-----------------------------------------------------------------------------------
% Palabras clave
%-----------------------------------------------------------------------------------
\begin{keywords}
	Separadas,
	Por,
	Comas.
\end{keywords}

%-----------------------------------------------------------------------------------
% Temas
%-----------------------------------------------------------------------------------
\begin{topics}
	Tema, Subtema.
\end{topics}


%-----------------------------------------------------------------------------------
% NO BORRAR ESTAS LINEAS!
%-----------------------------------------------------------------------------------
\vspace{0.8cm}
]
%-----------------------------------------------------------------------------------


%===================================================================================

%===================================================================================
% Introducción
%-----------------------------------------------------------------------------------
\section{Introducción}\label{sec:intro}
%-----------------------------------------------------------------------------------
	El sistema de coma flotante es una notación científica que usan las computadoras para representar números reales muy pequeños y a la vez muy grandes con relativa rapidez y eficiencia.
  
	El modelo por el cual se basan estas aritméticas es el estándar IEEE 754, este formato comprende:
	\begin{enumerate}
  
  		\item Representación de números finitos: cada número finito se caracteriza por una base $b$, un bit de signo $s$, una mantisa $c$ y un exponente $q$. Entonces un número $v$ se define como: $v=(-1)^s\cdot c\cdot b^q$. 
  	
  		\item Los números infinitos: $\pm\infty$.
  	
  		\item Un valor no numérico: $NaN$ el cual indica que en algún proceso de cálculo realizado se efectuó una operación que no resultó en un número correctamente definido, por ejemplo una división por 0.
	\end{enumerate}
  
	El IEEE 754 también establece las reglas básicas para operar con los números de la aritmética tal es el caso de las de la representación en memoria de los números, los formatos de precisión y los formatos de intercambio y redondeo.
  
	Las aritméticas de punto fijo son un método para representar números reales, guardando solamente un número fijo de sus decimales. Esta representación se basa en la utilización de potencias negativas de una misma base para representar la parte fraccionaria de un número. Esta aritmética contrasta con la aritmética de punto flotante anteriormente descrita, ya que es mucho menos compleja de implementar, pero también menos efectiva. Dado que las antiguas calculadoras mecánicas contaban con este sistema, actualmente se utiliza el sistema de coma flotante en los modernos microprocesadores.
  
	Las aritméticas abordadas anteriormente en muchas ocasiones no pueden representar exactamente los números que les proporcionamos ya que solo pueden guardar una parte finita del número, por lo que realmente operaremos con aproximaciones de estos números, lo que conlleva a la consideración de los errores de truncamiento y redondeo que se cometen durante este proceso.
  
	Las aritméticas de fracciones racionales se basan en la representación de números racionales mediante una fracción racional que consta de un numerador y un denominador enteros. Dicha aritmética puede minimizar los errores de redondeo y truncamiento que se cometen en las aritméticas anteriormente descritas, pero en varias ocasiones su computo suele ser bastante más complejo que en las anteriores.
  
	Otro de los puntos a considerar en los sistemas descritos anteriormente es que la mayoría de ellos trabajan en base 2, lo cual se debe a la implementación de los microprocesadores, entonces otro error que nos podemos plantear en este análisis es el intercambio entre bases, ya que comúnmente trabajamos en base 10 y nuestra computadora en base 2, este problema es el que trataremos de resolver con la aritmética propuesta en este trabajo.

  
  
%===================================================================================



%===================================================================================
% Desarrollo
%-----------------------------------------------------------------------------------
\section{Biblioteca BigNum}\label{sec:big_num}
%-----------------------------------------------------------------------------------  
	BigNum es una aritmética basada en las aritméticas de punto fijo, ya que cuenta con una cantidad fija de lugares decimales, la cual se puede cambiar dinámicamente desde el código una vez que se instancia. Utilizaremos como base las potencias de 10 (siempre y cuando dicha base sea representable en la aritmética de enteros con que cuenta nuestra computadora), para no cometer en los errores que se producen durante el intercambio de bases los cuales ilustraremos posteriormente.

  
  \lstset{keywordstyle=\color{blue}, basicstyle=\small}

		\begin{figure}[htb]%
			\begin{lstlisting}[language=python]%

    def __init__(self, precision=6,
                 ind_base10: int = 9):
                 
        self.__precision = precision
        self.__base10 = 10 ** ind_base10
        self.__ind_base10 = ind_base10


			\end{lstlisting}
		\caption{Constructor de BigNum.\label{fig:code}}
		\end{figure}
	
	Para instanciar BigNum necesitaremos los parámetros \textbf{precision} el número de lugares decimales con respecto a nuestra base y \textbf{ind\_base10} el exponente de la base 10 que tendrá la base de la aritmética. Notemos que la cantidad total de lugares decimales que puede representar nuestra aritmética es la multiplicación de
\textbf{precision} y  \textbf{ind\_base10}, para los parámetros por defecto tenemos 54 lugares decimales.
  
	
%-----------------------------------------------------------------------------------
\subsection{Representación de los Números}\label{sub:representation}
%-----------------------------------------------------------------------------------
	Modelaremos los número de nuestra aritmetica mediante la clase \textbf{Numbers}:
	\lstset{keywordstyle=\color{blue}, basicstyle=\small}

		\begin{figure}[htb]%
			\begin{lstlisting}[language=python]%

    def __init__(self, 
                 number: str|float|list,         
                 positive: bool, 
                 precision: int, 
                 ind_base10: int, 
                 base10: int):

			\end{lstlisting}
		\caption{Constructor de Numbers.\label{fig:code}}
		\end{figure}
	
	Los parámetros \textbf{number}, \textbf{positive}, \textbf{precision}, \textbf{ind\_base10} y \textbf{base10} 
  reciben la representación del número, el signo del número, la precisión, exponete de la base 10 y la base respectivamente. Notemos que la representación de los números puede estar dada por una variable del tipo \textbf{list}, \textbf{float} o \textbf{str}, en los dos últimos casos transformamos el dicho formato a  una lista de enteros que finalmente será la representación en memoria del número. Cada posición de la lista representa el bit correspondiente a esa posición y almacena un número entero $x$ tal que $0\leq x <base$.  
  
  
%-----------------------------------------------------------------------------------
\subsection{Operaciones Básicas}\label{sub:basic operations}
%-----------------------------------------------------------------------------------

	Las operaciones básicas que podemos realizar con los números de la clase \textbf{Numbers} son la adición, substracción, multiplicación y división en el formato del sistema numérico posicional con que actualmente trabajamos. Como dichas operaciones se producen bit a bit y dado que nuestros bits son números enteros y conocemos que la aritmética de la computadora es exacta, aprovecharemos dicha ventaja y modificaremos la base de nuestra aritmética a potencias de 10 (que soporte la aritmética entera) para acelerar el computo con respecto a un sistema de numeración de base 10, ya que entonces para computar las operaciones entre números de igual cantidad de decimales en base 10 necesitaremos menos iteraciones bit a bit.
  
	Para la adición y substracción utilizaremos el algoritmo clásico de suma y resta bit a bit llevando los respectivos acarreos.


%-----------------------------------------------------------------------------------
\subsubsection{Multiplicación algortimo de Karatsuba}\label{sub:multiplication}
%-----------------------------------------------------------------------------------
	El algoritmo de Karatsuba consiste en reducir la multilicación de dos números de $n$ digítos a como máximo 
	$3n^{\log_2 3}\approx 3n^{1.585}$ multiplicaciones de números de un solo dígito, lo cual mejora el algoritmo clásico de multiplicación que consta de $n^2$ operaciones de un solo dígito. Este algoritmo se simienta en las bases de los algoritmos de \emph{Divide y Vencerás} utilizando el caso particular de la partición binaria.
	
	A continuación presentamos una descripsión del algoritmo:
	
	Sean $a$ y $b$ dos numeros de $n$ dígitos tal que:
		\begin{equation}
			\begin{split}
				&a=a_1 10^{\lfloor {n\over 2}\rfloor} + a_2 \wedge b=b_1 10^{\lfloor {n\over 2}\rfloor} + b_2	\\	
				&\Rightarrow ab=a_1 b_1\cdot 10^{2\cdot\lfloor {n\over 2}\rfloor}+(a_1 b_2+b_1 a_2 )10^{\lfloor {n\over 2}\rfloor}+a_2 b_2
			\end{split}
		\end{equation}			
			
	 Entonces tenemos que $a_1$ y $b_1$ poseen a lo sumo $\lceil {n\over 2}\rceil$ dígitos y $a_2$ y $b_2$ tienen $\lfloor {n\over 2}\rfloor$ dígitos, por lo que para realizar el computo de $ab$ necesitamos calcuar 4 multiplicaciones y una suma de a lo sumo $\lceil {n\over 2}\rceil$ dígitos.
	 
	 Este algoritmo es particularmente muy eficiente en multuplicaciones de enteros grandes, por ejemplo para $n=1024$, el costo del algoritmo sería $3^{10}=59049$ comparado con el clásico que sería de $2^20=1049756$ operaciones. 
	
	
%-----------------------------------------------------------------------------------
\subsubsection{División algortimo D}\label{sub:division}
%-----------------------------------------------------------------------------------
	Ahora nos enfrentaremos a un problema más complejo que es la división de dos números. El algoritmo básico para la división consiste en mecanismo de prueba y error mediante el sistema de numeración posicional y el mismo tiene una complejidad de $d\cdot m\cdot n$, donde $d$ es una contante en la aritmética que viene dada por la base y $m$ y $n$ son la cantidad de dígitos del numerador y el denominador. Por tanto como anteriormente planteamos la idea de aumentar el tamaño de la base para que las operaciones fueran más eficientes aquí nos hemos encontrado con un problema que se agrava con dicha propuesta.
	
	Para solucionar el problema descrito anteriormente plantearemos dos algoritmos como alternativa al algoritmo clásico el primero es el \emph{Algoritmo de Newtón-Raphlson} y el segundo es el \emph{Algoritmo D}.
	
	Newtón-Raphlson es un algoritmo de división que pertenece a los algoritmos de división rápidos y que actualmente se usa en los métodos de división de los microprocesadores modernos. Este algoritmo consiste en la aproximación del inverso del divisor mediante una serie de iteraciones.
	
	Sean $x_0$, $x_1$, $\ldots$, $x_s$ aproximaciones del recíproco del divisor($d$) y $f(x)=dx-1$:
	\begin{equation}
		x_{i+1}=x_i-{f(x_i)\over f'(x_i)}=x_i+{{1\over x_i}-d\over{1\over x^2_i}} =x_i(2-dx_i)
	\end{equation}
	
	Como nuestro objetivo es brindar una aritmética lo más exacta posible no consideraremos este algoritmo para su implementación, pero a continuación abordamos un algoritmo menos eficiente pero en el que no cometemos errores de aproximación fuera de los errores de truncamiento y redondeo.
	
	El Algoritmo D se basa en la estimación del cociente que resulta de dividir un número de $n+1$ dígitos entre otro de $n$ dígitos. Esta estimación se realiza mediante la división de el número formado por los dos primeros dígitos del dividendo entre el número formado por el primer dígito del divisor, a continuación mostraremos como acotar dicha estimación:
	
	Sea $a$ un número de $n+1$ dígitos y $b$ un número de $n$ dígitos y $d$ la base de nuestra aritmética tales que:
		$$a=\overline{a_{n+1}a_n\ldots a_1} \wedge b=\overline{b_n\ldots b_1}$$	 
	
	Primero como $a-\overline{a_{n+1}a_n} d^{n-1}= a_{n-1}\ldots a_1\leq b_n d^{n-1}$ tenemos que:
	\begin{equation}
		\Bigg\lfloor{a \over b_nd^{n-1}}\Bigg\rfloor = \Bigg\lfloor{\overline{a_{n+1}a_n} d^{n-1} \over b_n d^{n-1}}\Bigg\rfloor
	\end{equation}
	
	Ahora sea $q=\lfloor{a \over b}\rfloor$ y $q'=\lfloor{\overline{a_{n+1}a_n} \over b_n}\rfloor$, sabemos que $q\geq q'$ por lo demostrado anteriormente, por lo tanto trataremos de acotar el error que se comete en la estimación de $q'$:
	\begin{equation}
		\begin{split}
			&q-q'=\Bigg\lfloor{a \over b_n d^{n-1}}\Bigg\rfloor-\Bigg\lfloor{a \over b_n d^{n-1}+d^n-1}\Bigg\rfloor\\ 
			&q-q'<{a \over b_n d^{n-1}}-{a \over b_n d^{n-1}+d^n-1}+1\\
			&q-q'<{a(b_n d^{n-1}+d^{n-1}-1-b_n d^{n-1})\over b_n d^{n-1}(b_n d^{n-1}+d^{n-1}-1)}+1\\
			&q-q'<{d^{n-1}-1\over b_n d^{n-1}}\cdot {a
\over b_n d^{n-1}+d^{n-1}-1}+1\\
			&q-q'<{1\over b_n}\cdot d+1={d\over b_n}+1
		\end{split}
	\end{equation}
	
	Luego solo nos queda acotar ${d\over b_n}$, mostremos que simpre podemos hacer transformaciones para que ${d\over b_n}\leq 2$, para ello apoyémonos en el sistema decimal que es el que utilizamos en nuestra aritmética. 
	
	Por ejemplo si $b_n$ es 2 podemos multiplicar el numerador y el denominador por 3, al cual llamaremos factor de normalización, en el caso peor que el denominador sea $\overline{299\ldots} \cdot 3= \overline{6\ldots }$, de la misma manera podemos encontrar un factor de normalización. Para extender este ejemplo para la base $10^k$ simplemente multiplicamos por $10^x$ de tal manera que $b_n$ tenga exactamente $k$ dígitos y luego aplicamos el proceso descrito anteriormente.
	
	De esta manera comprobamos que al realizar la estimación de nuestro cociente cometemos a lo sumo un error de 3 unidades, por lo que tendremos que hacer a lo sumo 3 comprobaciones para asegurarnos de que el resultado es correcto. Luego nuestro algoritmo realizará $3mn$ iteraciones en el caso peor al realizar la división de un número de $m$ dígitos entre otro de $n$ dígitos. 
	
%-----------------------------------------------------------------------------------
\section{Biblioteca ArihmeticMath}\label{suc:arithmetic_math}
%-----------------------------------------------------------------------------------
	Para proceder a la comparación de los desempeños de las aritméticas vamos a establecer una biblioteca con implementaciones de las principales funciones matemáticas. Como plantilla base para las aritméticas definiremos la clase \textbf{ArithmeticMath} que cuenta de los siguientes métodos:
	
	\lstset{keywordstyle=\color{blue}, basicstyle=\small}

		\begin{figure}[htb]%
			\begin{lstlisting}[language=python]%

    @abstractmethod
    def number1(self):
        pass

    @abstractmethod
    def number0(self):
        pass
        
    @abstractmethod
    def float_to_number(self, 
                        number: float):
        pass
		
		\end{lstlisting}
		\caption{Métodos de ArithmeticMath.\label{fig:code}}
		\end{figure}
	
	Los métodos de la figura 3 tienen la función de definir el número 1 y el número 0 para cada aritmética, dado un \textbf{float} convertirlo al formato de la aritmética y  convertir un número de la aritmética a entero, respectivamente.
	
	\begin{figure}[htb]%
			\begin{lstlisting}[language=python]%

    def number_to_fraction(self, number):
        s = str(number).split('.')

        if len(s) == 1:
            return int(s[0]), 1

        return int(s[0] + s[1]),\
               int(add_zeros_right('1',\
               len(s[1])))

		
		\end{lstlisting}
		\caption{Método NumberToFraction.\label{fig:code}}
		\end{figure}
		
	Adicionalmente se encuentra predefinido el método de la figura 4, el cual se encarga de convertir un número de la aritmética en una fracción racional, retornando 2 entero el numerador y el denominador en ese orden.
	
%-----------------------------------------------------------------------------------
\subsection{Funciones de ArihmeticMath}\label{sub:functions}
%-----------------------------------------------------------------------------------

	
	Como mencionamos anteriormente esta aritmética cuenta con métodos que permiten la implementación de las principales funciones matemáticas, a continuación, detallamos los recursos matemáticos utilizados en cada caso:
	
	\begin{enumerate}
		\item Raíz n-ésima: Para esta operación se trata de buscar un valor cercano mediante una potencia entera ($x_0$ aproximación inicial) y luego se aproxima mediante la siguiente relación de recurrencia:
			\begin{equation}
				x_ {k + 1} = {\frac {1} {n}} \left [{(n-1) x_ {k} + {\frac {A} {x_ {k} ^ {n-1}}}} \right]
			\end{equation}
		
		donde $x_i\approx \sqrt[n]{A}$.
			
		\item Potencia: Para esta operación se busca la fracción que genera el exponente y luego se calcula la raíz y la potencia correspondiente.
  		
  		\item Logaritmo en base $e$: Se aproxima mediante la serie de Taylor de la función $\text{ln}(1-x)$, con $|x| \leq 1$:
  			\begin{equation}
  				\text{ln}(1-x)=-\sum _{n=1}^{\infty }{\frac {x^{n}}{n}}
			\end{equation}  			 
			si $|x| > 1$ se utiliza la siguiente identidad $\text{ln}({1\over x})=-\text{ln}(x)$.
			
		\item Logaritmo: Se aproxima mediante la identidad $\text{log}_a b={\text{ln}(a)\over \text{ln}(b)}$, con el cálculo de los logaritmos en base $e$ correspondientes.
		
		\item Seno: Se aproxima mediante la serie de Taylor de la función $\text{sen }x$:
  			\begin{equation}
  				\text{sen } x=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{(2n+1)!}}
  			\end{equation}
  			
  		\item Coseno: Se aproxima mediante la serie de Taylor de la función $\text{cos }x$:
  			\begin{equation}
  				\text{cos } x=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{(2n)!}}
  			\end{equation}
  			
  		\item Tangente y Cotangente: Se calculan mediante las identidades fundamentales: $\text{sen x}\over \text{cos x}$ y $\text{cos x}\over \text{sen x}$, respectivamente.
  			
  		\item Arcoseno: Se aproxima mediante la serie de Taylor de la función $\text{arcsen }x$, para $\left|x\right|<1$:
  			\begin{equation}
  				\text{arcsen }x=\sum _{n=0}^{\infty }{\frac {(2n)!}{4^{n}(n!)^{2}(2n+1)}}\;x^{2n+1}\quad
  			\end{equation}
  			
  		\item Arcocoseno: Se aproxima mediante la identidad $\text{arccos}x={\pi \over 2}-\text{arcsin }x$, con el cálculo del arcoseno correspondiente.
  		
  		\item Arcotangente: Se aproxima mediante la serie de Taylor de la función $\text{arctan }x$, con $|x| \leq 1$, si $|x| > 1$ se utiliza la siguiente identidad $\text{arctan }x={\pi \over 2}-\text{arctan}({1 \over x})$:
  			\begin{equation}
  				\text{arctan }x=\sum _{n=0}^{\infty }{\frac {(-1)^{n}}{2n+1}}\;x^{2n+1}
  			\end{equation}
  			
  		\item Arcocotangente: Se aproxima mediante la identidad $\text{arccot }x={\pi \over 2}-\text{arctan }x$, con el cálculo de la arcotangente correspondiente.
  		
  		\item Número $\pi$: Se aproxima mediante la serie la función $\text{arcsen }x$ evaluada en 0.5 que tiene como resultado $\pi\over 6$.
  		
  		\item Número $e$: Se aproxima mediante la serie de Taylor de la función $e^x$, evaluada en 1:
  			\begin{equation}
  				e^{x}=\sum _{n=0}^{\infty }{\frac {x^{n}}{n!}}
  			\end{equation}
	\end{enumerate}

%-----------------------------------------------------------------------------------
\section{Comparando las Aritméticas}\label{sub:comp_aritmetics}
%-----------------------------------------------------------------------------------
	En esta sección contaremos con 5 aritméticas, cada una basadas en \textbf{ArithmeticMath}:
	\begin{enumerate}
		\item BigNum: Nuestra biblioteca con las especificaciones mencionadas anteriormente.
		
		\item DecimalNum: Apoyada en el módulo \textbf{Decimal} de \textbf{Python}, para realizar las operaciones básicas.
		
		\item FractionNum: Apoyada en el módulo \textbf{Fraction} de \textbf{Python}, para realizar las operaciones básicas.
		
		\item Extended754Num: Apoyada para realizar las operaciones básicas en \textbf{Extended174}, aritmética de base variable bajo el estándar IEEE-174, desarrollada en la
		Facultad. 
		
		\item Aritmética estándar: Utilización del módulo \textbf{Math} y los números \textbf{float} de \textbf{Python}.
	\end{enumerate}


%-----------------------------------------------------------------------------------
\subsection{Problemas y Limitaciones del Punto Flotante}\label{sub:problems_limitations}
%-----------------------------------------------------------------------------------
	Como mencionamos anteriormente en la introducción el sistema de coma flotante que se implementa en los microprocesadores de nuestra computadora es en base 2, el número $0.25={2\over 10}+{5\over 100}={25\over 100}={1\over 4}$ de ahí que se 0.25 en binario se exprese como 0.01. 
	
	Un problema aparente que podemos observar a simple vista es que en muchas ocasiones la fracción decimal no se pueda expresar mediante un número finito de decimales, por ejemplo ${1\over 3}=0.333333\ldots$, ahora podemos observar que lo mismo ocurre en base 2, por ejemplo $0.4={4\over 10}={2\over 5}$ que en binario seria ${10\over 101}=0.0110011001100110\ldots$. Con el ejemplo analizado anteriormente se nos presenta el siguiente problema $0.4={4\over 10}$, sin embargo ${10\over 101}=0.0110011001100110\ldots$, es decir para la misma fracción racional nos encontramos con que 0.4 es perfectamente representable en base 10 con un número finito de decimales pero en base 2 obtenemos $0.0110011001100110\ldots$ que es un número infinito periódico. Esto supone un importante problema ya que en la vida cotidiana fuera del mundo de la computación se trabaja en base 10, sin embargo las computadoras y los sistemas computo están hechos en su mayoría para el procesamiento de datos de la vida real, lo cual trae consigo que verdaderamente se trabaje con una aproximación de estos datos y no con los números introducidos originalmente (Figura 5).
	
	\begin{figure}
		\begin{center}
			\includegraphics[scale=1]{recourses/repre04.png}
			\caption{Representación de 0.4 como float.\label{fig:code}}
		\end{center}
	\end{figure}
	
	\begin{figure}
		\begin{center}
			\includegraphics[scale=1]{recourses/comp04mult3.png}
			\caption{Comparación de números flotantes.\label{fig:code}}
		\end{center}
	\end{figure}
	
	Otro problema que debemos de tener en cuenta a la hora de trabajar con estas aproximaciones es la comparación de los números obtenidos, por ejemplo ilustremos la comparación mostrada en la Figura 6 donde podemos apreciar que en el sistema de coma flotante $0.4\cdot 3$ es ligeramente superior a 1.2.

\onecolumn
%-----------------------------------------------------------------------------------
\subsection{Tablas y Valores Obtenidos}\label{sub:table}
%-----------------------------------------------------------------------------------
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.00000000000000023846264338327950288419718393539484659  &  0.0276847    \\ \hline
FractionNum  &  1.2246467991473532e-16                                   &  0.00103831   \\ \hline
DecimalNum   &  1.224646799150525701746457189E-16                        &  6.19888e-05  \\ \hline
\end{tabular}
		\caption{Cálculo de sen($\pi$). \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.841470984807896506652502321630298999622563060798371067  &  0.0127552    \\ \hline
FractionNum  &  0.8414709848078965                                        &  0.000446081  \\ \hline
DecimalNum   &  0.8414709848078965066525023216                            &  5.31673e-05  \\ \hline

\end{tabular}
		\caption{Cálculo de sen(1). \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  3.141592653589793238462643383279502884197169399375105588  &  0.174473     \\ \hline
FractionNum  &  3.141592653589793                                         &  0.00294471   \\ \hline
DecimalNum   &  3.141592653589793238462643381                             &  0.000238657  \\ \hline

\end{tabular}
		\caption{Cálculo de $\pi$. \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  2.718281828459045235360287471352662497757247093698703317  &  0.0109069    \\ \hline
FractionNum  &  2.718281828459045                                         &  0.000371218  \\ \hline
DecimalNum   &  2.718281828459045235360287474                             &  4.31538e-05  \\ \hline

\end{tabular}
		\caption{Cálculo de $e$. \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  3.524193849218783867017024061131077780596772055958075561  &  0.0921957    \\ \hline
FractionNum  &  3.5241938492187836                                        &  0.00212646   \\ \hline
DecimalNum   &  3.524193849218783867017024054                             &  0.000117302  \\ \hline

\end{tabular}
		\caption{Cálculo de ln(34). \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.999999999999999913415788971088737539870366147960492922  &  0.0782981    \\ \hline
FractionNum  &  1.0                                                       &  0.0125442    \\ \hline
DecimalNum   &  0.9999999999999999468176229340                            &  0.000138283  \\ \hline

\end{tabular}
		\caption{Cálculo de ln($e$). \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.000000000000000019231321691639751442098584699687551724  &  0.0247827   \\ \hline
FractionNum  &  6.123233995736766e-17                                     &  0.00112844  \\ \hline
DecimalNum   &  6.123233995815319195807292141E-17                         &  6.1512e-05  \\ \hline

\end{tabular}
		\caption{Cálculo de cos($\pi\over 2$). \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  -0.839071529076449284094014962603313164795669011492621151  &  0.0178885    \\ \hline
FractionNum  &  -0.8390715290764493                                        &  0.000496149  \\ \hline
DecimalNum   &  -0.8390715290764492840940147683                            &  5.45979e-05  \\ \hline

\end{tabular}
		\caption{Cálculo de cos($\pi\over 2$). \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  3.091634257867850477052637096244658002705892318951598412  &  0.293755   \\ \hline
FractionNum  &  3.0916342578678506                                        &  0.155865   \\ \hline
DecimalNum   &  3.091634257867850477052637094                             &  0.0010519  \\ \hline

\end{tabular}
		\caption{Cálculo de atan(20). \label{fig:ex}}
		\end{center}
	\end{figure}	
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.137330723949833581285581892462466056727664713273587321  &  0.293775     \\ \hline
FractionNum  &  -  &  -     \\ \hline
DecimalNum   &  0.1373307239498335812855818925                            &  0.000308752  \\ \hline

\end{tabular}
		\caption{Cálculo de $\sqrt[12]{45}$. \label{fig:ex}}
		\end{center}
	\end{figure}	
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.141421356237309504880168872420969807856967187537694807  &  0.0277922    \\ \hline
FractionNum  &  -  &  -    \\ \hline
DecimalNum   &  0.1414213562373095048801688724                            &  8.86917e-05  \\ \hline

\end{tabular}
		\caption{Cálculo de $\sqrt{2}$. \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.000000140296115413079060775723153661975661722367225558  &  0.0339777    \\ \hline
FractionNum  &  -  &  -    \\ \hline
DecimalNum   &  1.402961154130790607757231540E-7                          &  0.000280619  \\ \hline

\end{tabular}
		\caption{Cálculo de $3^{4.5}$. \label{fig:ex}}
		\end{center}
	\end{figure}
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  0.177245385090551596002909775228635189621673846583109667  &  0.0289474    \\ \hline
FractionNum  &  -  &  -    \\ \hline
DecimalNum   &  0.1772453850905515992751519103                            &  8.63075e-05  \\ \hline

\end{tabular}
		\caption{Cálculo de $\pi^{0.5}$. \label{fig:ex}}
		\end{center}
	\end{figure}	
	
	\begin{figure}[h!]%
		\begin{center}
			\begin{tabular}{|c|l|l|} \hline
			 			& Valor 	    & Tiempo 	\\ \hline
			BigNum       &  1.514354028437096828855179419136122881185661180257748239  &  0.130738     \\ \hline
FractionNum  &  1.5143540284370969                                        &  0.00287724   \\ \hline
DecimalNum   &  1.514354028437096828855179423                             &  0.000198841  \\ \hline

\end{tabular}
		\caption{Cálculo de asin(1). \label{fig:ex}}
		\end{center}
	\end{figure}	
	
	
\twocolumn
	

%-----------------------------------------------------------------------------------
	\subsection{Listas y Descripciones}\label{sub:lists}
%-----------------------------------------------------------------------------------
		Para producir listas enumeradas, utilice el siguiente estilo:
		\begin{enumerate}
			\item Primer Elemento
			\item Segundo Elemento
			%
			\begin {enumerate}
				\item {Segundo Elemento - Subítem Uno}
				\item {Segundo Elemento - Subítem Dos}
			\end {enumerate}
			%
		\end{enumerate}

%-----------------------------------------------------------------------------------
		Para producir descripciones, use el siguiente estilo:

%-----------------------------------------------------------------------------------
		\begin{description}
			\item [Primer Elemento] con su respectiva descripción.
			\item [Segundo Elemento] también con su respectiva descripción.
		\end{description}

%-----------------------------------------------------------------------------------
	\subsection{Figuras}\label{sub:figures}
%-----------------------------------------------------------------------------------
		Para producir cuerpos flotantes (figuras o tablas), asegúrese de numerar
		y etiquetar correctamente cada figura. Las referencias a las figuras deben
		estar correctamente etiquetadas. Por ejemplo, véase la Fig. \ref{fig:ex}\ldots
		
%-----------------------------------------------------------------------------------
	\subsection{Código Fuente}\label{sub:listings}
%-----------------------------------------------------------------------------------
		Para producir código fuente, envuélvalo en una figura flotante y
		etiquételo correctamente. Por ejemplo, en la Fig. \ref{fig:code}
		se muestra un código bastante conocido\ldots

		% Configuración de Listings
		\lstset{keywordstyle=\color{blue}, basicstyle=\small}

		\begin{figure}[htb]%
			\begin{lstlisting}[language=c]%

    int main(int argc, char** argv)
    {
        // Imprimiendo "Hola Mundo".
        printf("Hello, World");
    }

			\end{lstlisting}
		\caption{Código fuente de ejemplo.\label{fig:code}}
		\end{figure}

%-----------------------------------------------------------------------------------
	\subsection{Referencias}
%-----------------------------------------------------------------------------------
  	Las referencias deben estar agrupadas en una sección al final del artículo,
  	y las citas numeradas correctamente, por ejemplo \cite{knuth} o \cite{goedel}.
  	Incluya toda la información importante de cada referencia, incluídos autor,
  	título, y notas de la edición. En caso de citar sitios web, además
  	de la URL, incluya la fecha en que fue consultado, como en \cite{wiki}. Numere 
  	las referencias según el orden en que se les cita.

%===================================================================================



%===================================================================================
% Conclusiones
%-----------------------------------------------------------------------------------
\section{Conclusiones}\label{sec:conc}

  En esta sección puede incluir las conclusiones de su investigación y las ideas
  sobre la continuidad del trabajo, en el caso que aplique.

%===================================================================================



%===================================================================================
% Recomendaciones
%-----------------------------------------------------------------------------------
\section{Recomendaciones}\label{sec:rec}

  En esta sección puede incluir recomendaciones sobre posibles formas de continuar
  la investigación u otros temas relacionados.

%===================================================================================



%===================================================================================
% Bibliografía
%-----------------------------------------------------------------------------------
\begin{thebibliography}{99}
%-----------------------------------------------------------------------------------
	\bibitem{wiki} Algorithm D. URL: \href{https://ridiculousfish.com/blog/posts/labor-of-division-episode-iv.html}
	  {https://ridiculousfish.com/blog/posts/labor-of-division-episode-iv.html}.
		Consultado en 19 de noviembre de 2022.
		
	\bibitem{wiki} Algoritmo para calcular la raíz n. URL: \href{https://es.frwiki.wiki/wiki/Algorithme_de_calcul_de_la_racine_n-i\%C3\%A8me}
	  {https://es.frwiki.wiki/wiki/Algorithme\_de\_calcul\_de\_la\_racine\_n-i\%C3\%A8me}.
		Consultado en 19 de noviembre de 2022.
	
	\bibitem{wiki} IEEE-174-1985. Wikipedia. URL: \href{https://en.wikipedia.org/wiki/IEEE_754-1985}
	  {https://en.wikipedia.org/wiki/IEEE\_754-1985}.
		Consultado en 19 de noviembre de 2022.
		
	\bibitem{wiki} Karatsuba algorithm. Wikipedia. URL: \href{https://en.wikipedia.org/wiki/Karatsuba_algorithm}
	  {https://en.wikipedia.org/wiki/Karatsuba\_algorithm}.
		Consultado en 19 de noviembre de 2022.	
		
	\bibitem{wiki} Taylor Series. Wikipedia. URL: \href{https://en.wikipedia.org/wiki/Taylor_series}
	  {https://en.wikipedia.org/wiki/Taylor\_series}.
		Consultado en 19 de noviembre de 2022.
		
	
	
	
	

%-----------------------------------------------------------------------------------
\end{thebibliography}

%-----------------------------------------------------------------------------------

\label{end}

\end{document}

%===================================================================================
